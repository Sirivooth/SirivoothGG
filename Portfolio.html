<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Robot Animation with Dynamic Fog</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
  // Scene
  const scene = new THREE.Scene();

  // ðŸŽ­ Fog Effect (Exponential Dynamic Fog)
  scene.fog = new THREE.FogExp2(0xaaaaaa, 0.015);
  let fogTime = 0;

  // Camera
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(15, 10, 25);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMappingExposure = 1.2;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 0, 0);
  controls.update();

  // === Lights ===
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambientLight);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  hemiLight.position.set(0, 50, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(-20, 30, -10);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 4096;
  dirLight.shadow.mapSize.height = 4096;
  scene.add(dirLight);

  const spotLight = new THREE.SpotLight(0xffffff, 1.5, 100, Math.PI / 6, 0.3, 1);
  spotLight.position.set(10, 30, 10);
  spotLight.castShadow = true;
  spotLight.target.position.set(0, 0, 0);
  scene.add(spotLight);
  scene.add(spotLight.target);

  const pointLight1 = new THREE.PointLight(0xff5555, 1, 50);
  pointLight1.position.set(-10, 10, 0);
  scene.add(pointLight1);

  const pointLight2 = new THREE.PointLight(0x55aaff, 1, 50);
  pointLight2.position.set(10, 10, 0);
  scene.add(pointLight2);

  const pointLight3 = new THREE.PointLight(0xffffff, 0.8, 60);
  pointLight3.position.set(0, 15, -15);
  scene.add(pointLight3);

  // Load EXR background (HDRI)
  const exrLoader = new THREE.EXRLoader();
  exrLoader.load("docklands_02_1k.exr", function(texture) {
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
    scene.background = envMap;
    scene.environment = envMap;
    texture.dispose();
  });

  // === Ground (30x30) ===
  const textureLoader = new THREE.TextureLoader();
  const floorDiffuse = textureLoader.load("concrete_pavers_02_diff_1k.jpg");
  const floorNormal  = textureLoader.load("concrete_pavers_02_nor_gl_1k.jpg");
  const floorRough   = textureLoader.load("concrete_pavers_02_rough_1k.jpg");

  [floorDiffuse, floorNormal, floorRough].forEach(tex => {
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(6, 6); // tile à¹ƒà¸«à¹‰à¸žà¸­à¸”à¸µà¸à¸±à¸šà¸žà¸·à¹‰à¸™à¹ƒà¸«à¸à¹ˆà¸‚à¸¶à¹‰à¸™
  });

  const groundMat = new THREE.MeshStandardMaterial({
    map: floorDiffuse,
    normalMap: floorNormal,
    roughnessMap: floorRough,
    metalness: 0.0,
    roughness: 1.0
  });

  const groundGeo = new THREE.PlaneGeometry(30, 30); // à¸žà¸·à¹‰à¸™à¸‚à¸™à¸²à¸” 30x30
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // --- à¹‚à¸«à¸¥à¸”à¹‚à¸¡à¹€à¸”à¸¥à¸«à¸¸à¹ˆà¸™à¸¢à¸™à¸•à¹Œ + Animation ---
  let mixer;
  const loader = new THREE.GLTFLoader();
  loader.load(
    "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
    function(gltf) {
      const model = gltf.scene;
      model.traverse(node => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });
      model.position.set(0, 0, 0);
      model.scale.set(0.5, 0.5, 0.5);
      scene.add(model);

      mixer = new THREE.AnimationMixer(model);
      const clips = gltf.animations;
      const clip = THREE.AnimationClip.findByName(clips, "Dance");
      if (clip) {
        mixer.clipAction(clip).play();
      } else {
        const idle = THREE.AnimationClip.findByName(clips, "Idle");
        if (idle) mixer.clipAction(idle).play();
      }
    }
  );

  // Animate
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);

    // Dynamic Fog
    fogTime += delta * 0.5; 
    scene.fog.density = 0.012 + Math.sin(fogTime) * 0.004;

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
