<!DOCTYPE html>
<html>
<head>
  <title>3D Game-like Controller with GUI</title>
  <style> body { margin:0; overflow:hidden; cursor: grab; } </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

<script>
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(0,3,10);

// Lights
const dirLight1 = new THREE.DirectionalLight(0xffffff,1.2);
dirLight1.position.set(5,10,5); dirLight1.castShadow=true; scene.add(dirLight1);
const dirLight2 = new THREE.DirectionalLight(0xffffff,0.8);
dirLight2.position.set(-10,8,-10); dirLight2.castShadow=true; scene.add(dirLight2);
const ambientLight = new THREE.AmbientLight(0xffffff,0.6);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffffff,0.5,50);
pointLight.position.set(0,10,0); pointLight.castShadow=true; scene.add(pointLight);

// Floor
const textureLoader = new THREE.TextureLoader();
const floorMaterial = new THREE.MeshStandardMaterial({
  color:0xffffff, metalness:0.1, roughness:0.8,
  map: textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg'),
  normalMap: textureLoader.load('https://threejs.org/examples/textures/brick_normal.jpg'),
  aoMap: textureLoader.load('https://threejs.org/examples/textures/brick_ao.jpg')
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), floorMaterial);
floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

// Buildings
const buildingMaterial = new THREE.MeshStandardMaterial({
  color:0xaaaaaa, metalness:0.3, roughness:0.6,
  map: textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg'),
  normalMap: textureLoader.load('https://threejs.org/examples/textures/brick_normal.jpg')
});
for(let i=0;i<50;i++){
  const w=Math.random()*3+1;
  const h=Math.random()*8+2;
  const d=Math.random()*3+1;
  const x=(Math.random()-0.5)*80;
  const z=(Math.random()-0.5)*80;
  const building = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), buildingMaterial);
  building.position.set(x,h/2,z);
  building.castShadow=true; building.receiveShadow=true;
  scene.add(building);
}

// Load GLB
let model;
const loader = new THREE.GLTFLoader();
loader.load('cyclone_sonic_voyage.glb', gltf=>{
  model=gltf.scene;
  model.position.set(0,0,0);
  model.scale.set(1,1,1);
  model.traverse(node=>{ if(node.isMesh){ node.castShadow=true; node.receiveShadow=true; } });
  scene.add(model);
});

// Controls
const keys={w:false,a:false,s:false,d:false};
document.addEventListener('keydown', e=>{ if(keys[e.key.toLowerCase()]!==undefined) keys[e.key.toLowerCase()]=true; });
document.addEventListener('keyup', e=>{ if(keys[e.key.toLowerCase()]!==undefined) keys[e.key.toLowerCase()]=false; });

// Mouse rotation
let isMouseDown=false;
let prevX=0, prevY=0;
let yaw=0, pitch=0;
document.addEventListener('mousedown', e=>{ isMouseDown=true; prevX=e.clientX; prevY=e.clientY; document.body.style.cursor='grabbing'; });
document.addEventListener('mouseup', e=>{ isMouseDown=false; document.body.style.cursor='grab'; });
document.addEventListener('mousemove', e=>{
  if(isMouseDown){
    const dx=e.clientX-prevX;
    const dy=e.clientY-prevY;
    yaw -= dx*0.005;
    pitch -= dy*0.005;
    pitch=Math.max(-Math.PI/3, Math.min(Math.PI/3,pitch));
    prevX=e.clientX; prevY=e.clientY;
  }
});

// GUI
const gui = new dat.GUI();

const lightFolder = gui.addFolder("Lights");
const dir1Folder = lightFolder.addFolder("Directional Light 1");
dir1Folder.add(dirLight1.position, 'x', -20,20).name("X");
dir1Folder.add(dirLight1.position, 'y', 0,20).name("Y");
dir1Folder.add(dirLight1.position, 'z', -20,20).name("Z");
dir1Folder.add(dirLight1, 'intensity', 0,5).name("Intensity");
dir1Folder.add(dirLight1, 'castShadow').name("Cast Shadow");

const dir2Folder = lightFolder.addFolder("Directional Light 2");
dir2Folder.add(dirLight2.position, 'x', -20,20).name("X");
dir2Folder.add(dirLight2.position, 'y', 0,20).name("Y");
dir2Folder.add(dirLight2.position, 'z', -20,20).name("Z");
dir2Folder.add(dirLight2, 'intensity', 0,5).name("Intensity");
dir2Folder.add(dirLight2, 'castShadow').name("Cast Shadow");

const ambientFolder = lightFolder.addFolder("Ambient Light");
ambientFolder.add(ambientLight, 'intensity', 0,2).name("Intensity");

const pointFolder = lightFolder.addFolder("Point Light");
pointFolder.add(pointLight.position, 'x', -20,20).name("X");
pointFolder.add(pointLight.position, 'y', 0,20).name("Y");
pointFolder.add(pointLight.position, 'z', -20,20).name("Z");
pointFolder.add(pointLight, 'intensity', 0,5).name("Intensity");
pointFolder.add(pointLight, 'castShadow').name("Cast Shadow");

lightFolder.open();
dir1Folder.open();
dir2Folder.open();
ambientFolder.open();
pointFolder.open();

// Animate
function animate(){
  requestAnimationFrame(animate);
  if(model){
    const moveSpeed=0.15;

    let moveDir = new THREE.Vector3();
    if(keys.w) moveDir.z-=1;
    if(keys.s) moveDir.z+=1;
    if(keys.a) moveDir.x-=1;
    if(keys.d) moveDir.x+=1;

    if(moveDir.length()>0){
      moveDir.normalize();
      moveDir.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      model.position.add(moveDir.multiplyScalar(moveSpeed));
      const angle=Math.atan2(moveDir.x, moveDir.z);
      model.rotation.y=angle;
    }

    const camOffset = new THREE.Vector3(0,3,10);
    const rotatedOffset = camOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    const camPos = model.position.clone().add(rotatedOffset);
    camera.position.lerp(camPos,0.1);
    const lookAtPos = model.position.clone().add(new THREE.Vector3(0,1,0));
    camera.lookAt(lookAtPos);
  }

  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
